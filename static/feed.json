{
    "version": "https://jsonfeed.org/version/1",
    "title": "Russell Jones Blog",
    "home_page_url": "https://blog.jonesrussell42.xyz/",
    "feed_url": "https://blog.jonesrussell42.xyz/feed.json",
    "description": "Blog posts and contact information of a Full Stack Developer and DevOps expert.",
    "icon": "https://blog.jonesrussell42.xyz/apple-touch-icon.png",
    "favicon": "https://blog.jonesrussell42.xyz/favicon.ico",
    "expired": false,
    
"items": [
    
        {
            "id": "laravel-2021-04-03-start-developing-with-laravel-in-ubuntu-20-04",
            "title": "Start Developing with Laravel in Ubuntu 20.04",
            "summary": null,
            "content_text": "First and foremost, I find Ubuntu the Linux distribution easiest to install and best supported when learning Web Development. I’m sure that’s open for debate, but that’s what the comments are for.OK, I’m running Ubuntu, what next?I suggest that your install Homebrew, “The Missing Package Manager for macOS (or Linux)”. It’s great but if you choose another path, I hope you can still follow along.I have Homebrew, now what?Install DDEV[DDEV](https://github.com/drud/ddev) is an open  source tool that makes it dead simple to get local PHP development  environments up and running within minutes. It's powerful and flexible  as a result of its per-project environment configurations, which can be  extended, version controlled, and shared. In short, DDEV aims to allow  development teams to use Docker in their workflow without the  complexities of bespoke configuration.Follow the directions at https://ddev.readthedocs.io/en/stable/#installation which will ensure you have everything needed to install DDEV and then Laravel.Install LaravelCopy and paste from below, replace MY_SITE=”” with the name you wish to choose for you site:MY_SITE=my-laravel-appmkdir $MY_SITEcd $MY_SITEddev config --project-type=laravel --docroot=public --create-docrootddev startddev composer create --prefer-dist laravel/laravelddev exec \"cat .env.example | sed  -E 's/DB_(HOST|DATABASE|USERNAME|PASSWORD)=(.*)/DB_\\1=db/g' &gt; .env\"ddev exec \"php artisan key:generate\"ddev launchBing, bang, boom. I have some LaravelThe ddev launch command should have opened your default browser to this screen:",
            "content_html": "<p>First and foremost, I find <a href=\"https://ubuntu.com/tutorials/install-ubuntu-desktop#1-overview\">Ubuntu</a> the Linux distribution easiest to install and best supported when learning Web Development. I’m sure that’s open for debate, but that’s what the comments are for.</p><h2 id=\"ok-im-running-ubuntu-what-next\">OK, I’m running Ubuntu, what next?</h2><p>I suggest that your <a href=\"https://blog.aamnah.com/sysadmin/install-homebrew-ubuntu-linux\">install Homebrew</a>, “The Missing Package Manager for macOS (or Linux)”. It’s great but if you choose another path, I hope you can still follow along.</p><h2 id=\"i-have-homebrew-now-what\">I have Homebrew, now what?</h2><h3 id=\"install-ddev\">Install DDEV</h3><blockquote>[DDEV](https://github.com/drud/ddev) is an open  source tool that makes it dead simple to get local PHP development  environments up and running within minutes. It's powerful and flexible  as a result of its per-project environment configurations, which can be  extended, version controlled, and shared. In short, DDEV aims to allow  development teams to use Docker in their workflow without the  complexities of bespoke configuration.</blockquote><p>Follow the directions at https://ddev.readthedocs.io/en/stable/#installation which will ensure you have everything needed to install DDEV and then Laravel.</p><h3 id=\"install-laravel\">Install Laravel</h3><p>Copy and paste from below, replace MY_SITE=”” with the name you wish to choose for you site:</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">MY_SITE</span><span class=\"o\">=</span>my-laravel-app<span class=\"nb\">mkdir</span> <span class=\"nv\">$MY_SITE</span><span class=\"nb\">cd</span> <span class=\"nv\">$MY_SITE</span>ddev config <span class=\"nt\">--project-type</span><span class=\"o\">=</span>laravel <span class=\"nt\">--docroot</span><span class=\"o\">=</span>public <span class=\"nt\">--create-docroot</span>ddev startddev composer create <span class=\"nt\">--prefer-dist</span> laravel/laravelddev <span class=\"nb\">exec</span> <span class=\"s2\">\"cat .env.example | sed  -E 's/DB_(HOST|DATABASE|USERNAME|PASSWORD)=(.*)/DB_</span><span class=\"se\">\\1</span><span class=\"s2\">=db/g' &gt; .env\"</span>ddev <span class=\"nb\">exec</span> <span class=\"s2\">\"php artisan key:generate\"</span>ddev launch</code></pre></div></div><h2 id=\"bing-bang-boom-i-have-some-laravel\">Bing, bang, boom. I have some Laravel</h2><p>The <em>ddev launch</em> command should have opened your default browser to this screen:</p><p><img src=\"/assets/img/laravel.png\" alt=\"\" /></p>",
            "url": "https://blog.jonesrussell42.xyz/laravel/2021/04/03/start-developing-with-laravel-in-ubuntu-20.04.html",
            "image": "/assets/img/laravel.png",
            
            
            "tags": ["web-development","install"],
            
            "date_published": "2021-04-03T00:00:00+00:00",
            "date_modified": "2021-04-03T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "web-development-2021-03-06-imposter-syndrome-my-2",
            "title": "Imposter Syndrome",
            "summary": null,
            "content_text": "Ahnii! Notice the exclamation point? The Ojibwe greeting for ‘Hello’?20 years ago I’d slink in the corner and be silent, let alone shout an ‘Indian’ greeting at you.20 years ago I felt like an imposter in the eyes of my co-workers. Meanwhile, I was actually kicking ass.IntroductionI’m a talented 41 year old Anishnawbek Web Developer who grew up on a Northern Ontario Indian Reservation as defined by the Canadian Indian Act of 1875, under amendments up until 1951 since I was born in 1979.It wasn’t until the amendments of 1985 that I was “enfranchised”.What does that mean? Under the Indian Act:By enfranchising, a person was supposed to be consenting to abandon  Indigenous identity and communal society (with its artificial legal  disabilities) in order to merge with the \"free,\" individualistic and  non-Aboriginal majority.In other words, in Kindergarten I went to an Indian Day School where the purpose was to Anglicize us into conformity. I suppose I was lucky in the sense that by Grade 1 I was able to attend a school operated by people of my community rather than people appointed by Government or Church.What does that have to do with Imposter Syndrome?And, what is Imposter Syndrome?As defined by verwellmind:Impostor syndrome (IS) refers to an internal experience of believing  that you are not as competent as others perceive you to be. While this  definition is usually narrowly applied to intelligence and achievement,  it has links to perfectionism and the social context.A little technical I know, thankfully so do they:    To put it simply, imposter syndrome is the experience of feeling like a  phony—you feel as though at any moment you are going to be found out as a fraud—like you don't belong where you are, and you only got there  through dumb luck. It can affect anyone no matter their social status,  work background, skill level, or degree of expertise.Am I an Imposter Person?Seems dramatic sure. But growing up as I did on a reservation surrounded by ‘White’ towns, where in the 80’s the local town bar had an ‘Indian’ side and a ‘White’ side, it gets confusing to be a minority ‘in your own land’.The Developer ConnectionI believe my life experience goes hand in hand with my feelings of Imposter Syndrome in the Web Development world. It’s been a struggle of 4 decades to accept that I am not a phoney human, developer, or any other label I care to attach to myself.My past was confusing, challenging, heart-breaking, and sometimes tragic. But I had a loving, compassionate, and nurturing family to help get through.Ever since IRC, I’ve always felt this online, open-source community to be the nurturing family of my professional life. I’ve come to rely on it and you have all helped me find my confidence as a developer.I have worth. I am a great web developer.Check out my newest launch, my personal portfolio built on Svelte, TypeScript &amp; Kubernetes at https://www.jonesrussell42.xyz. The repository is public at https://github.com/jonesrussell/portfolio-sapper.Now what?This is now an open-source world and every company is a software company.You’re worth it. So do the work.Meegwetch! (Thank you)P.S. I look forward to hearing from you all.",
            "content_html": "<p>Ahnii! Notice the exclamation point? The Ojibwe greeting for ‘Hello’?</p><p>20 years ago I’d slink in the corner and be silent, let alone shout an ‘Indian’ greeting at you.</p><p>20 years ago I felt like an imposter in the eyes of my co-workers. Meanwhile, I was actually kicking ass.</p><p class=\"center\"><img src=\"https://blog.jonesrussell42.xyz/assets/img/imposter-syndrome.png\" alt=\"scripts screenshot\" class=\"half center\" /></p><h2 id=\"introduction\">Introduction</h2><p>I’m a talented 41 year old Anishnawbek Web Developer who grew up on a <a href=\"https://sagamok.ca/\">Northern Ontario Indian Reservation</a> as defined by the Canadian Indian Act of 1875, under amendments up until 1951 since I was born in 1979.</p><p>It wasn’t until the amendments of 1985 that I was “enfranchised”.</p><p>What does that mean? Under the Indian Act:</p><blockquote>By enfranchising, a person was supposed to be consenting to abandon  Indigenous identity and communal society (with its artificial legal  disabilities) in order to merge with the \"free,\" individualistic and  non-Aboriginal majority.</blockquote><p>In other words, in Kindergarten I went to an <a href=\"https://en.wikipedia.org/wiki/Canadian_Indian_residential_school_system\">Indian Day School</a> where the purpose was to Anglicize us into conformity. I suppose I was lucky in the sense that by Grade 1 I was able to attend a school operated by people of my community rather than people appointed by Government or Church.</p><h2 id=\"what-does-that-have-to-do-with-imposter-syndrome\">What does that have to do with Imposter Syndrome?</h2><h3 id=\"and-what-is-imposter-syndrome\">And, what is Imposter Syndrome?</h3><p>As defined by <a href=\"https://www.verywellmind.com/imposter-syndrome-and-social-anxiety-disorder-4156469\">verwellmind</a>:</p><blockquote>Impostor syndrome (IS) refers to an internal experience of believing  that you are not as competent as others perceive you to be. While this  definition is usually narrowly applied to intelligence and achievement,  it has links to perfectionism and the social context.</blockquote><p>A little technical I know, thankfully so do they:</p><blockquote>    To put it simply, imposter syndrome is the experience of feeling like a  phony—you feel as though at any moment you are going to be found out as a fraud—like you don't belong where you are, and you only got there  through dumb luck. It can affect anyone no matter their social status,  work background, skill level, or degree of expertise.</blockquote><h3 id=\"am-i-an-imposter-person\">Am I an Imposter Person?</h3><p>Seems dramatic sure. But growing up as I did on a reservation surrounded by ‘White’ towns, where in the 80’s the local town bar had an ‘Indian’ side and a ‘White’ side, it gets confusing to be a minority ‘in your own land’.</p><h2 id=\"the-developer-connection\">The Developer Connection</h2><p>I believe my life experience goes hand in hand with my feelings of Imposter Syndrome in the Web Development world. It’s been a struggle of 4 decades to accept that I am not a phoney human, developer, or any other label I care to attach to myself.</p><p>My past was confusing, challenging, heart-breaking, and sometimes tragic. But I had a loving, compassionate, and nurturing family to help get through.</p><p>Ever since IRC, I’ve always felt this online, open-source community to be the nurturing family of my professional life. I’ve come to rely on it and you have all helped me find my confidence as a developer.</p><p>I have worth. I am a great web developer.</p><p>Check out my newest launch, my personal portfolio built on Svelte, TypeScript &amp; Kubernetes at https://www.jonesrussell42.xyz. The repository is public at https://github.com/jonesrussell/portfolio-sapper.</p><h2 id=\"now-what\">Now what?</h2><p>This is now an open-source world and every company is a software company.</p><p><strong>You’re worth</strong> it. So do the <strong>work</strong>.</p><p>Meegwetch! (Thank you)</p><p>P.S. I look forward to hearing from you all.</p>",
            "url": "https://blog.jonesrussell42.xyz/web-development/2021/03/06/imposter-syndrome-my-2.html",
            "image": "/assets/img/imposter-syndrome.png",
            
            
            "tags": ["my-2-¢","self-worth","humans"],
            
            "date_published": "2021-03-06T00:00:00+00:00",
            "date_modified": "2021-03-06T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "nodejs-2020-12-21-quickly-view-nodejs-project-scripts-on-the-cli",
            "title": "Quickly view nodejs project 'scripts' on the cli",
            "summary": null,
            "content_text": "Ahnii! I previously wrote a command line utility named ‘packages’ which simply prints a list of project dependencies on the command line.I found that I also often want to see a list of scripts in package.json, so I wrote another utility I’ve named ‘scripts’, observe:You can accomplish the same with ‘sed’, but it’s quite a command to remember, observe:sed -n -e '/scripts/,/},/ p' package.jsonCheck it out at https://github.com/jonesrussell/scripts or simply install it and try:npm i -g @jonesrussell42/scriptsMeegwetch!",
            "content_html": "<p>Ahnii! I previously wrote a command line utility named ‘<a href=\"/_posts/2020-11-21-quickly-view-project-dependencies-on-the-cli.html\">packages</a>’ which simply prints a list of project dependencies on the command line.</p><p>I found that I also often want to see a list of scripts in package.json, so I wrote another utility I’ve named ‘scripts’, observe:</p><p class=\"center\"><img src=\"https://blog.jonesrussell42.xyz/assets/img/screenshot-scripts.png\" alt=\"scripts screenshot\" class=\"half center\" /></p><p>You can accomplish the same with ‘sed’, but it’s quite a command to remember, observe:</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">sed</span> <span class=\"nt\">-n</span> <span class=\"nt\">-e</span> <span class=\"s1\">'/scripts/,/},/ p'</span> package.json</code></pre></div></div><p class=\"center\"><img src=\"https://blog.jonesrussell42.xyz/assets/img/screenshot-scripts-sed.png\" alt=\"scripts sed screenshot\" /></p><p>Check it out at <a href=\"https://github.com/jonesrussell/scripts\">https://github.com/jonesrussell/scripts</a> or simply install it and try:</p><div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>npm i <span class=\"nt\">-g</span> @jonesrussell42/scripts</code></pre></div></div><p>Meegwetch!</p>",
            "url": "https://blog.jonesrussell42.xyz/nodejs/2020/12/21/quickly-view-nodejs-project-scripts-on-the-cli.html",
            "image": "/assets/img/screenshot-scripts.png",
            
            
            "tags": ["cli","web-development"],
            
            "date_published": "2020-12-21T00:00:00+00:00",
            "date_modified": "2020-12-21T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "2020-11-21-quickly-view-project-dependencies-on-the-cli",
            "title": "Quickly view project dependencies on the cli",
            "summary": null,
            "content_text": "Ahnee! I frequently find myself on the command line wanting to know which dependencies and devDependencies are in the package.json file.I do it frequently enough that I decided to experiment with commander and create a command line utitlity in JavaScript/TypeScript.Check it out at https://github.com/jonesrussell/packages or simply:npm i -g @jonesrussell42/packagesMeegwetch!",
            "content_html": "<p>Ahnee! I frequently find myself on the command line wanting to know which dependencies and devDependencies are in the package.json file.</p><p>I do it frequently enough that I decided to experiment with commander and create a command line utitlity in JavaScript/TypeScript.</p><p><img src=\"/assets/img/screenshot-packages.png\" alt=\"packages screenshot\" /></p><p>Check it out at <a href=\"https://github.com/jonesrussell/packages\">https://github.com/jonesrussell/packages</a> or simply:</p><div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>npm i <span class=\"nt\">-g</span> @jonesrussell42/packages</code></pre></div></div><p>Meegwetch!</p>",
            "url": "https://blog.jonesrussell42.xyz/2020/11/21/quickly-view-project-dependencies-on-the-cli.html",
            "image": "/assets/img/screenshot-packages.png",
            
            
            "tags": ["cli","web-development"],
            
            "date_published": "2020-11-21T00:00:00+00:00",
            "date_modified": "2020-11-21T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "web-development-2020-04-24-ddev-for-drupal",
            "title": "Use DDEV to locally develop with Drupal",
            "summary": null,
            "content_text": "I’ve been developing with Drupal for over 10 years. It’s never been known to be quick and easy to install, but with the rise of containers it’s now as easy as executing a few commands in a terminal.PrerequisitesInstalling the prerequisites is beyond the scope of this post but here is a linked list of what you need installed on your system:  Composer  Docker version 18.06 or higher  Docker Compose  DDEVDownload &amp; Install Drupal      composer has become the de-facto standard package manager of PHP projects and the Drupal recommended way to manage a Drupal installation:    # use composer to download Drupalcomposer create-project drupal/recommended-project my-drupal-site \\    &amp;&amp; cd $_ # $_ will contain 'my-drupal-site'            DDEV is a wrapper for Docker Compose that spins up containers configured to serve PHP projects with an SQL database:    # create a ddev config and settings.php for Drupalddev config --docroot web --project-name $_ --project-type drupal8            Start the containers:    ddev start        Once the containers successfully start a link will be displayed to visit your site:    Successfully started my-drupal-siteProject can be reached at http://my-drupal-site.ddev.site http://127.0.0.1:32780            Before Drupal is usable it must be installed. You can click through the install wizard or use drush, a command-line utility for Drupal, that comes installed with DDEV:    ddev exec drush site-install -y --account-name=admin --account-pass=my-password      That’s it! Drupal is installed and running at http://my-drupal-site.ddev.site.LoginYou can login with the following credentials:username: adminpassword: my-passwordFurther ReadingDocumentation: https://ddev.readthedocs.io/en/latest/DDEV includes some handy functionality, like running composer and drush within the web container to download and install new modules.You can easily import/export your database, or tap into ngrok to share a browse-able link to your project accessible from the internet.Happy developing! Gabekana.",
            "content_html": "<p>I’ve been developing with Drupal for over 10 years. It’s never been known to be quick and easy to install, but with the rise of containers it’s now as easy as executing a few commands in a terminal.</p><h2 id=\"prerequisites\">Prerequisites</h2><p>Installing the prerequisites is beyond the scope of this post but here is a linked list of what you need installed on your system:</p><ul>  <li><a href=\"https://getcomposer.org/download/\">Composer</a></li>  <li><a href=\"https://docs.docker.com/get-docker/\">Docker</a> version 18.06 or higher</li>  <li><a href=\"https://docs.docker.com/compose/install/\">Docker Compose</a></li>  <li><a href=\"https://ddev.readthedocs.io/en/latest/#installation\">DDEV</a></li></ul><h2 id=\"download--install-drupal\">Download &amp; Install Drupal</h2><ol>  <li>    <p><em>composer</em> has become the de-facto standard package manager of PHP projects and the Drupal recommended way to manage a Drupal installation:</p>    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># use composer to download Drupal</span>composer create-project drupal/recommended-project my-drupal-site <span class=\"se\">\\</span>    <span class=\"o\">&amp;&amp;</span> <span class=\"nb\">cd</span> <span class=\"nv\">$_</span> <span class=\"c\"># $_ will contain 'my-drupal-site'</span></code></pre></div>    </div>  </li>  <li>    <p><em>DDEV</em> is a wrapper for <em>Docker Compose</em> that spins up containers configured to serve PHP projects with an SQL database:</p>    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># create a ddev config and settings.php for Drupal</span>ddev config <span class=\"nt\">--docroot</span> web <span class=\"nt\">--project-name</span> <span class=\"nv\">$_</span> <span class=\"nt\">--project-type</span> drupal8</code></pre></div>    </div>  </li>  <li>    <p>Start the containers:</p>    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ddev start</code></pre></div>    </div>    <p>Once the containers successfully start a link will be displayed to visit your site:</p>    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Successfully started my-drupal-siteProject can be reached at http://my-drupal-site.ddev.site http://127.0.0.1:32780</code></pre></div>    </div>  </li>  <li>    <p>Before Drupal is usable it must be installed. You can click through the install wizard or use <em>drush</em>, a command-line utility for Drupal, that comes installed with <em>DDEV</em>:</p>    <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ddev <span class=\"nb\">exec </span>drush site-install <span class=\"nt\">-y</span> <span class=\"nt\">--account-name</span><span class=\"o\">=</span>admin <span class=\"nt\">--account-pass</span><span class=\"o\">=</span>my-password</code></pre></div>    </div>  </li></ol><p>That’s it! Drupal is installed and running at <a href=\"http://my-drupal-site.ddev.site.\">http://my-drupal-site.ddev.site.</a></p><h2 id=\"login\">Login</h2><p>You can <a href=\"http://my-drupal-site.ddev.site/user/login\">login</a> with the following credentials:</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>username: adminpassword: my-password</code></pre></div></div><h2 id=\"further-reading\">Further Reading</h2><p>Documentation: <a href=\"https://ddev.readthedocs.io/en/latest/\">https://ddev.readthedocs.io/en/latest/</a></p><p>DDEV includes some handy functionality, like running composer and <a href=\"https://www.drush.org/\">drush</a> within the web container to download and install new modules.</p><p>You can easily import/export your database, or tap into <a href=\"https://ngrok.com/\">ngrok</a> to share a browse-able link to your project accessible from the internet.</p><p>Happy developing! Gabekana.</p>",
            "url": "https://blog.jonesrussell42.xyz/web-development/2020/04/24/ddev-for-drupal.html",
            
            
            
            "tags": ["drupal","docker","devops","php"],
            
            "date_published": "2020-04-24T00:00:00+00:00",
            "date_modified": "2020-04-24T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "mildly-interesting-2018-10-25-whalebrew",
            "title": "Whalebrew",
            "summary": null,
            "content_text": "Docker Images as ‘Native’ Commands  Ahnee! If you’re from the Mac World you’ve probably used, or at least heard of,  Homebrew. For the uninformed, Homebrew is  The missing package manager for macOS. Or more accurately it’s a package management system for macOS that’s  comparable to Redhat’s RPM, Debian’s APT, and  Window’s Chocolatey.  Package managers make installing software easy by automagically fetching a pre-compiled binary and its dependencies,  then copying them into your $PATH.  Depending on the software, compiling from source code is often difficult and time-consuming. Package managers let you  get on with the using the software.Installing With APT    figlet displays large characters made up of ordinary screen charactersI’ll demonstrate installing a package with APT in Ubuntu 18.10:$ sudo apt install figlet  As you can see in the screenshot, APT downloads the figlet package (figlet_2.2.5–3_amd64.deb), unpacks it, then  finally installs to /usr/bin/figlet.$ figlet &quot;p4ck4g3&#39;s 4 l1fe\\!&quot;    figlet in actionI Whale Always Love You  Whalebrew is an inevitable side effect of container proliferation. Their ease of use, speed, and low resource  consumption make them ideal vehicles for single command or function execution.  As I’ve  previously    written, containers can be started, perform a task, then stopped in a matter of milliseconds. And that’s exactly  what  Whalebrew allows you to do in the form of Docker images aliased in your $PATH.Now let’s put a magnifying glass up to Whalebrew by walking through its installation then “install a package”.Whalebrew Demonstration  By creating an alias for running a Docker container and storing it in $PATH, running a command within a container is  seamless and virtually indistinguishable from running a command directly in the environment.  What does that look like exactly? Assuming you already have  Docker    installed, we’ll start by installing Whalebrew (from  https://github.com/bfirsh/whalebrew):$ sudo curl -L &quot;https://github.com/bfirsh/whalebrew/releases/download/0.1.0/whalebrew-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/whalebrew; sudo chmod +x /usr/local/bin/whalebrew    Whalebrew installed to /usr/local/bin/whalebrewNow let’s install figlet again, but this time with Whalebrew:$ sudo whalebrew install whalebrew/figlet    whalebrew/figlet installed to /usr/local/bin/figlet  Now let’s run figlet again and adore the glorious results (We’ll use the full path in case the APT figlet is first  in $PATH):$ /usr/local/bin/figlet &quot;It&#39;s a whale of a time\\!&quot;    figlet as run in a Docker container  Tada! We’ve just run figlet from within a container. You may have noticed it took a bit longer to execute, depending  on your computer’s runtime juice.  So what just happened? Before we wrap it up we’ll take a quick look under the hood and examine the difference between  running a native binary and a Whalebrew command.Native vs. ‘Native’        Facsimile of an      Indian Painting    Maazhichige, wrong ‘native’! The figlet program installed with APT is an ELF executable, the  source code compiled from C, and it runs directly on your system.The Whalebrew alias looks like this:$ cat /usr/local/bin/figlet  When a package is executed, Whalebrew will run the specified image with Docker, mount the current working directory in  /workdir, and pass through all of the arguments.And this is essentially what Whalebrew executes:$ docker run -it -v &quot;$(pwd)&quot;:/workdir -w /workdir whalebrew/figlet &quot;It&#39;s a whale of a time\\!&quot;And well, that’s it, move along. Baamaapii.",
            "content_html": "<h4>Docker Images as ‘Native’ Commands</h4><p>  Ahnee! If you’re from the Mac World you’ve probably used, or at least heard of,  <a href=\"https://brew.sh/\">Homebrew</a>. For the uninformed, Homebrew is  <em>The missing package manager for macOS. </em>Or more accurately it’s a package management system for macOS that’s  comparable to Redhat’s <a href=\"http://rpm.org/\">RPM</a>, Debian’s <a href=\"https://wiki.debian.org/Apt\">APT</a>, and  Window’s <a href=\"https://chocolatey.org/\">Chocolatey</a>.</p><p>  Package managers make installing software easy by automagically fetching a pre-compiled binary and its dependencies,  then copying them into your $PATH.</p><p>  Depending on the software, compiling from source code is often difficult and time-consuming. Package managers let you  get on with the using the software.</p><h3>Installing With APT</h3><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*MLwvtPEG0yoOEtCzml-R9Q.png\" />  <figcaption>figlet displays large characters made up of ordinary screen characters</figcaption></figure><p>I’ll demonstrate installing a package with APT in Ubuntu 18.10:</p><pre><strong>$</strong> sudo apt install figlet</pre><p>  As you can see in the screenshot, APT downloads the figlet package (figlet_2.2.5–3_amd64.deb), unpacks it, then  finally installs to /usr/bin/figlet.</p><pre><strong>$</strong> figlet &quot;p4ck4g3&#39;s 4 l1fe\\!&quot;</pre><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*XkvZZOmATGe8p6Ri2ZqOaA.png\" />  <figcaption>figlet in action</figcaption></figure><h3>I Whale Always Love You</h3><p>  Whalebrew is an inevitable side effect of container proliferation. Their ease of use, speed, and low resource  consumption make them ideal vehicles for single command or function execution.</p><p>  As I’ve  <a href=\"https://medium.com/@jonesrussell42/docker-for-legacy-drupal-development-6df4dec8b309#b965\">previously    written</a>, containers can be started, perform a task, then stopped in a matter of milliseconds. And that’s exactly  what  Whalebrew allows you to do in the form of Docker images aliased in your $PATH.</p><p>Now let’s put a magnifying glass up to Whalebrew by walking through its installation then “install a package”.</p><h3>Whalebrew Demonstration</h3><p>  By creating an alias for running a Docker container and storing it in $PATH, running a command within a container is  seamless and virtually indistinguishable from running a command directly in the environment.</p><p>  What does that look like exactly? Assuming you already have  <a href=\"https://medium.com/@jonesrussell42/docker-for-legacy-drupal-development-6df4dec8b309#db40\">Docker    installed</a>, we’ll start by installing Whalebrew (from  <a href=\"https://github.com/bfirsh/whalebrew\">https://github.com/bfirsh/whalebrew</a>):</p><pre><strong>$</strong> sudo curl -L &quot;https://github.com/bfirsh/whalebrew/releases/download/0.1.0/whalebrew-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/whalebrew; sudo chmod +x /usr/local/bin/whalebrew</pre><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*EzjhwX8SPJ-Zlcjxiayt2A.png\" />  <figcaption>Whalebrew installed to /usr/local/bin/whalebrew</figcaption></figure><p>Now let’s install figlet again, but this time with Whalebrew:</p><pre><strong>$</strong> sudo whalebrew install whalebrew/figlet</pre><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*bLCbFgBYsdCcLfeKnr2UpA.png\" />  <figcaption>whalebrew/figlet installed to /usr/local/bin/figlet</figcaption></figure><p>  Now let’s run figlet again and adore the glorious results (We’ll use the full path in case the APT figlet is first  in $PATH):</p><pre><strong>$</strong> /usr/local/bin/figlet &quot;It&#39;s a whale of a time\\!&quot;</pre><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*X8Eew1wrMcMjbw2-skNPGQ.png\" />  <figcaption>figlet as run in a Docker container</figcaption></figure><p>  Tada! We’ve just run figlet from within a container. You may have noticed it took a bit longer to execute, depending  on your computer’s <em>runtime juice</em>.</p><p>  So what just happened? Before we wrap it up we’ll take a quick look under the hood and examine the difference between  running a native binary and a Whalebrew command.</p><h3>Native vs. ‘Native’</h3><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*zpAHqMDHdy4hqXN3fo1hAQ.jpeg\" />  <figcaption>    <a href=\"http://bibliodyssey.blogspot.com/2006/08/bodmer-series-on-native-america.html\">Facsimile of an      Indian Painting</a>  </figcaption></figure><p>  Maazhichige, wrong ‘native’! The figlet program installed with APT is an ELF executable, the  <a href=\"https://github.com/cmatsuoka/figlet\">source code</a> compiled from C, and it runs directly on your system.</p><p>The Whalebrew alias looks like this:</p><pre><strong>$</strong> cat /usr/local/bin/figlet</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*zMYeFQLlnwjjhttXCnVGiw.png\" /></figure><blockquote>  When a package is executed, Whalebrew will run the specified image with Docker, mount the current working directory in  /workdir, and pass through all of the arguments.</blockquote><p>And this is essentially what Whalebrew executes:</p><pre><strong>$</strong> docker run -it -v &quot;$(pwd)&quot;:/workdir -w /workdir whalebrew/figlet &quot;It&#39;s a whale of a time\\!&quot;</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*lSmdCGIGlEE6KDWGBHfFMA.png\" /></figure><p>And well, that’s it, move along. Baamaapii.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c3535b3c722\" width=\"1\"  height=\"1\" />",
            "url": "https://blog.jonesrussell42.xyz/mildly-interesting/2018/10/25/whalebrew.html",
            "image": "https://cdn-images-1.medium.com/max/734/1*MLwvtPEG0yoOEtCzml-R9Q.png",
            
            
            "tags": ["docker","linux"],
            
            "date_published": "2018-10-25T00:00:00+00:00",
            "date_modified": "2018-10-25T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "devops-2018-10-14-docker-for-legacy-drupal-development",
            "title": "Docker for Legacy Drupal Development",
            "summary": null,
            "content_text": "Leveraging Linux containers for Migrating Drupal 6 to Drupal 8  Ahnee. Let me start by saying this article/tutorial (artorial, tutarticle!?), this artorial could be titled  “Docker for Development, Leveraging Linux containers” and be applied to virtually any stack  you want.I’m using Drupal because I recently began a Drupal 6 (D6) to Drupal 8 (D8) website migration.  Drupal is a free, open-source content management system (CMS) with a large, supportive community. It’s used by  millions of people and organizations around the globe to build and maintain their websites.  Both versions run on a LAMP stack but with different versions of PHP. D6 reached it’s end-of-life in early 2016,  almost a year before PHP 7 was released. Consequently it requires PHP 5.6 and lower to run.  The folks at myDropWizard.com    are bravely supporting D6 until the cows come home, props to them! I have no affiliation with them, I’m just    thunderstruck by their level of      commitment.  According to the docs D8 will run on PHP 5.5.9+, but any version less than 7.1 is  not recommended.  If running Drupal 8 on PHP 5.6 you go, only pain will you find.  So how do you run PHP 5 and PHP 7 simultaneously on the same host? Spin up a pair of VMs?  Slip in Nginx and PHP-FPM alongside    Apache? The former option is acceptable. The latter borders on sadomasochism.    And there is, Kevin!The answer is, of course, Docker.This Guy’s Setup  I use Linux as my primary Operating System (OS). Ubuntu 18.04 loaded with the latest packages of Apache 2.4, MySQL  5.7, and PHP 7.2 from Ubuntu’s official repositories.Drupal 8  My Ubuntu host is similar enough to the production environment where D8 is to be deployed that I created an Apache  Virtual Host (vhost) and MySQL database then  downloaded    D8 using a composer template  and installed it with Drupal Console.  What is the Drupal Console? The Drupal CLI. A tool to generate boilerplate code, interact with and debug Drupal. From  the ground up, it has been built to utilize the same modern PHP practices which were introduced in Drupal 8.Drupal 6This is where the fun begins. But first I’ll explain the differences between a VM and a Container.VMs and Containers ComparedVM  There are many VM providers. VirtualBox,  QEMU, and VMWare to name a few. A VM  contains a full OS and kernel running in  isolation (so lonely) from the host. It is indistinguishable from a proper desktop or server.  Before booting, VMs are allocated resources such as RAM and CPU cores. The VM provides a hardware emulation layer  between the guest OS and the host, which looks and feels like bare metal as far as the guest OS is concerned.  Because they resemble physical desktops and servers, VMs require significant amounts of the host’s system resources.  In contrast to Containers this severely limits the amount of VMs that can run concurrently on a single host. The  boot-up and shutdown time is also the same as a physical machine; another significant difference.Containers  Containers offer the advantages of VMs without the overhead. By virtualizing at the kernel level containers share  resources with the host. Many more containers can run simultaneously on a single machine compared to VMs.  Containers worry more about resource prioritization rather than resource allocation. In other words, a container says  “When will you run this process for me niijikiwenh?” rather than “How much CPU do I have to run this process?”.  Finally, starting up or shutting down a Container is super fast *whoooooosh*. Because Containers share a  fully loaded kernel with the host, they can be started, perform a task, then shut down within milliseconds. Containers  are the mayflies of the tech world. On the flip side, they can last until an act of God brings them down along with  your house.DockerI messed with Docker years ago but only recently gave it a prime time slot in my regularly scheduled programming.  Docker makes it easier to create, deploy, and run an application in a lightweight and portable Container by packaging  it up with it’s dependencies and shipping them out as an image.  I’ve only skimmed the surface of Docker and don’t fully understand how it works under the hood. I’m also anxious to  check out a competitor such as Canonical’s LXD or  CoreOS/Redhat’s Rkt. All in good time.Docker Images  Docker loads an image containing an OS and the software needed to do a job into a container. In other words, an image  contains your applications runtime environment.  Creating an image is rather painless, depending on the complexity of your requirements. You write a set of  instructions in YAML saved as a Dockerfile, then run docker build. Our tutorial requirements are simple and can be met  with pre-existing images pulled from Docker Hub, a Docker image  registry service.  While I can find an image which contains Apache, PHP, and MySQL all together, we’re going to follow  best    practices  and separate the web server from the database into 2 containers where they will communicate through an internal subnet  created by Docker.Persisting Data  Finally, containers are designed to be disposable, with the ability to run as a single instance on a single host, or  to be scaled as multiple instances distributed over server clusters. By default, data is written to a containers  writable layer and will be disposed of along with the container.  Volumes and Bind Mounts are Dockers two options for persisting data. I can, and maybe will, write an entire post to  fully explain them. But to keep it brief I will say Volumes are managed by Docker, isolated from the host, can be  mounted into multiple containers, and stored on remote hosts or in a cloud provider.  Bind Mounts are a file or directory on the host machine mounted into a container. They are a good option to share  configuration data, source code, and build artifacts during development. In production, your build artifacts are best  copied directly into the image, configuration in the environment, and source code unnecessary.  Volumes are recommended for storing data used and generated by containers. Bind mounts depend on the host machine’s  directory structure, hampering container portability.In this tutorial we will get by with a bind mount.Summary  That’s Docker so far as I understand it. I hope you find it beneficial and are encouraged to begin developing with  Docker. I invite you to join in on the fun below and follow the step-by-step instructions to get down and dirty  with Docker.Tutorial  Let’s setup Drupal 6 within containers in Ubuntu. If you are not using Ubuntu don’t fret, the only step you need to  change is “Install Docker”. In that case refer to  https://docs.docker.com/install/#supported-platforms  for instructions to install Docker on your OS.If you catch any mistakes or see room for improvement please contact me. Otherwise, wacka wacka.Prerequisites  sudo (or root) — Required to install and run Docker. To run docker commands without sudo or root you must add your  user account to the docker group.Table of Contents  Install Docker  Add user to docker group  Start Docker  Pull MySQL image  Start container  Download Drupal 6  Pull Apache/PHP image  Enable mod_rewrite  Allow Overrides  Start container with a bind mount  Install Drupal  CleanupBiminizha’.Install DockerOpen a terminal and ensure your package lists are up to date then install Docker (aka Docker Engine):$ sudo apt update$ sudo apt install docker.io -yOutput:&lt;heaps of output&gt;Processing triggers for systemd (237-3ubuntu10.3) ...Docker Engine is comprised of three major components:  dockerd (Server) — a daemon that is a long-running background process  docker (Client) — a command line interface  REST API — specifies interfaces that programs can use to communicate with the daemonStart DockerKick-start the aforementioned long-running background process:$ sudo systemctl start dockerOptionally, tell systemd to start docker on system boot:$ sudo systemctl enable dockerDocker is now installed and ready for use. Check if docker is running:$ systemctl is-active dockerOutput:activePull MySQL image  Now that you have docker running you can pull your first image. Start with  MySQL version 5.6 (without :5.6  specified, :latest  is implied):$ sudo docker pull mysql:5.6Output:5.6: Pulling from library/mysql802b00ed6f79: Pull complete 30f19a05b898: Pull complete 3e43303be5e9: Pull complete 94b281824ae2: Pull complete 51eb397095b1: Pull complete 3f6fe5e46bae: Pull complete b5a334ca6427: Pull complete 115764d35d7a: Pull complete 719bba2efabc: Pull complete 284e66788ee1: Pull complete 0f085ade122c: Pull complete Digest: sha256:4c44f46efaff3ebe7cdc7b35a616c77aa003dc5de4b26c80d0ccae1f9db4a372Status: Downloaded newer image for mysql:5.6Start MySQLStart the DB container, options are explained below:$ sudo docker run -d \\--name=&quot;drupal-mysql&quot; \\-e MYSQL_ROOT_PASSWORD=drupalroot \\-e MYSQL_DATABASE=drupal6 \\-e MYSQL_USER=drupal \\-e MYSQL_PASSWORD=drupal6pass \\mysql:5.6  -d — Start the container as a background process.  --name —Will be referenced during Drupal install. A random name will be assigned if one isn’t provided.      -e — Set’s an environment variable. MySQL will be configured with    values passed in by the environment.  Output (will differ):de99c912e3fbeb4f113889c145b5fab82787259c21d51962c9186e90c27d2857Download Drupal 6  D6 is available for download from the official Drupal site packaged as a gzipped tarball. You can grab it with wget:$ cd ~$ wget https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz$ tar -xzf drupal-6.38.tar.gzVerify drupal-6.38 exists in your home directory:$ if test -d ~/drupal-6.38; then echo “It exists”; fiOutput:It existsPull Apache/PHP image  Now pull a docker image of Ubuntu 14.04 LTS with Apache 2, PHP 5, and Composer from  https://hub.docker.com/r/nimmis/apache-php5/:$ sudo docker pull nimmis/apache-php5Output:Using default tag: latestlatest: Pulling from nimmis/apache-php5c2c80a08aa8c: Pull complete 6ace04d7a4a2: Pull complete f03114bcfb25: Pull complete 99df43987812: Pull complete 9c646cd4d155: Pull complete 5c017123b62e: Pull complete 8f95d9abec41: Pull complete c46de42c66c3: Pull complete 9a19620cecad: Pull complete 5c62abdf642f: Pull complete Digest: sha256:712d35d5cc30e6a911e260e871f08f77d5684edcc50cba21163535714c547ff5Status: Downloaded newer image for nimmis/apache-php5:latestDocumentRoot and Incoming Port  The containerized Apache’s default DocumentRoot is /var/www/html, which we will bind mount to the D6 files in  ~/drupal-6.38.  Because I already have Apache on the host I have to bind the container’s port 80 to something else. I’m using 10080  but you can choose almost any other free port.$ sudo docker run -d  \\-p 10080:80 \\-v ~/drupal-6.38:/var/www/html \\--name=&quot;drupal-app&quot; \\--link=&quot;drupal-mysql&quot; \\nimmis/apache-php5Output:0398890ab8e0a082f68373c8e7fd088e925f9bac0eca178399b883091919ee77An explanation of what’s between run and nimmis/apache-php5:  -d — Daemonize, run in background.  -p 10080:80 — Bind host port 10080 to container port 80.  -v ~/drupal-6.38:/var/www/html — Bind host directory to container directory.  — name=&quot;drupal-app&quot; — Name the container instance for convenience.  --link=&quot;drupal-mysql&quot; — Link to the MySQL container so Drupal can communicate with the database.Install Drupal  Open http://localhost:10080 in a browser (xdg-open is a program that will    open a file or URL in the preferred application as set in your OS):$ xdg-open http://localhost:10080Tada! The Drupal 6 installation page should be open in a browser, served from within a set of Docker containers.  To complete the installation use the database name (drupal6), username (drupal), and password  (drupal6pass) as set in the Start MySQL step. Under Advanced Options, set the  Database host to the name of your MySQL container, drupal-mysql.CleanupWhen you have finished with Drupal 6 shut down the containers and delete them from the host.Stop the containers:$ sudo docker container stop drupal-app drupal-mysqlOutput:drupal-appdrupal-mysqlRemove the containers:$ sudo docker container rm drupal-app drupal-mysqlOutput:drupal-appdrupal-mysqlVerify the containers have been deleted:$ sudo docker container lsThat’s it, move along. Baamaapii.Bonus: docker groupTo display a list of groups you belong to is simple:$ groupOutput:roosta adm cdrom sudo dip plugdev lpadmin sambashareAdd your user account to the docker group:$ sudo usermod -aG docker $USERYou must log out then log back in before it takes effect.",
            "content_html": "<h4>Leveraging Linux containers for Migrating Drupal 6 to Drupal 8</h4><p>  Ahnee. Let me start by saying this article/tutorial (artorial, tutarticle!?), this <em>artorial </em>could be titled  “<strong>Docker for Development</strong>, <em>Leveraging Linux containers</em>” and be applied to virtually any stack  you want.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*s-YgL1NW7evYyCBWI-7w8Q.png\" /></figure><p>I’m using Drupal because I recently began a Drupal 6 (D6) to Drupal 8 (D8) website migration.</p><blockquote>  Drupal is a free, open-source content management system (CMS) with a large, supportive community. It’s used by  millions of people and organizations around the globe to build and maintain their websites.</blockquote><p>  Both versions run on a LAMP stack but with different versions of PHP. D6 reached it’s end-of-life in early 2016,  almost a year before PHP 7 was released. Consequently it requires PHP 5.6 and lower to run.</p><p>  <em>The folks at </em><a    href=\"https://www.mydropwizard.com/blog/drupal-6-year-2020-and-php-7-support\"><em>myDropWizard.com</em></a><em>    are bravely supporting D6 until the cows come home, props to them! I have no affiliation with them, I’m just    thunderstruck by their </em><a href=\"https://www.mydropwizard.com/blog/drupal-6-2019-yes-really\"><em>level of      commitment</em></a><em>.</em></p><p>  According to the docs D8 will run on PHP 5.5.9+, but any version less than 7.1 is  <a href=\"https://www.drupal.org/docs/8/system-requirements/php-requirements#php_required\">not recommended</a>.  <strong>If running Drupal 8 on PHP 5.6 you go, only pain will you find</strong>.</p><p>  So how do you run PHP 5 and PHP 7 simultaneously on the same host? Spin up a pair of VMs?  <a href=\"https://www.tecmint.com/install-different-php-versions-in-ubuntu/\">Slip in Nginx and PHP-FPM alongside    Apache</a>? The former option is acceptable. The latter borders on sadomasochism.</p><figure>  <img alt=\"\" src=\"https://cdn-images-1.medium.com/max/244/1*4jh-4MnN2NkYxWZVOKBklw.jpeg\" />  <figcaption>And there is, Kevin!</figcaption></figure><p>The answer is, of course, Docker.</p><h3>This Guy’s Setup</h3><p>  I use Linux as my primary Operating System (OS). Ubuntu 18.04 loaded with the latest packages of Apache 2.4, MySQL  5.7, and PHP 7.2 from Ubuntu’s official repositories.</p><h4>Drupal 8</h4><p>  My Ubuntu host is similar enough to the production environment where D8 is to be deployed that I created an Apache  Virtual Host (vhost) and MySQL database then  <a    href=\"https://www.drupal.org/docs/develop/using-composer/using-composer-to-manage-drupal-site-dependencies#download-core-option-a\">downloaded    D8 using a composer template</a>  and installed it with <a href=\"https://docs.drupalconsole.com/en/commands/site-install.html\">Drupal Console</a>.</p><blockquote>  What is the Drupal Console? The Drupal CLI. A tool to generate boilerplate code, interact with and debug Drupal. From  the ground up, it has been built to utilize the same modern PHP practices which were introduced in Drupal 8.</blockquote><h4>Drupal 6</h4><p>This is where the fun begins. But first I’ll explain the differences between a VM and a Container.</p><h3>VMs and Containers Compared</h3><h4>VM</h4><p>  There are many VM providers. <a href=\"https://www.virtualbox.org/\">VirtualBox</a>,  <a href=\"https://www.qemu.org/\">QEMU</a>, and <a href=\"https://www.vmware.com/\">VMWare</a> to name a few. A VM  contains a full OS and <a href=\"https://en.wikipedia.org/wiki/Kernel_(operating_system)\">kernel</a> running in  isolation (so lonely) from the host. It is indistinguishable from a proper desktop or server.</p><p>  Before booting, VMs are allocated resources such as RAM and CPU cores. The VM provides a hardware emulation layer  between the guest OS and the host, which looks and feels like bare metal as far as the guest OS is concerned.</p><p>  Because they resemble physical desktops and servers, VMs require significant amounts of the host’s system resources.  In contrast to Containers this severely limits the amount of VMs that can run concurrently on a single host. The  boot-up and shutdown time is also the same as a physical machine; another significant difference.</p><h4>Containers</h4><p>  Containers offer the advantages of VMs without the overhead. By virtualizing at the kernel level containers share  resources with the host. Many more containers can run simultaneously on a single machine compared to VMs.</p><p>  Containers worry more about resource prioritization rather than resource allocation. In other words, a container says  “When will you run this process for me niijikiwenh?” rather than “How much CPU do I have to run this process?”.</p><p>  Finally, starting up or shutting down a Container is super fast <em>*whoooooosh*</em>. Because Containers share a  fully loaded kernel with the host, they can be started, perform a task, then shut down within milliseconds. Containers  are the mayflies of the tech world. On the flip side, they can last until an act of God brings them down along with  your house.</p><h4>Docker</h4><p>I messed with Docker years ago but only recently gave it a prime time slot in my regularly scheduled programming.</p><p>  Docker makes it easier to create, deploy, and run an application in a lightweight and portable Container by packaging  it up with it’s dependencies and shipping them out as an image.</p><p>  I’ve only skimmed the surface of Docker and don’t fully understand how it works under the hood. I’m also anxious to  check out a competitor such as <a href=\"http://www.ubuntu.org.cn/cloud/lxd\">Canonical’s LXD</a> or  <a href=\"https://coreos.com/rkt/\">CoreOS/Redhat’s Rkt</a>. All in good time.</p><h4>Docker Images</h4><p>  Docker loads an image containing an OS and the software needed to do a job into a container. In other words, an image  contains your applications runtime environment.</p><p>  Creating an image is rather painless, depending on the complexity of your requirements. You write a set of  instructions in YAML saved as a Dockerfile, then run docker build. Our tutorial requirements are simple and can be met  with pre-existing images pulled from <a href=\"https://hub.docker.com/\">Docker Hub</a>, a Docker image  registry service.</p><p>  While I can find an image which contains Apache, PHP, and MySQL all together, we’re going to follow  <a href=\"https://devops.stackexchange.com/questions/447/why-it-is-recommended-to-run-only-one-process-in-a-container\">best    practices</a>  and separate the web server from the database into 2 containers where they will communicate through an internal subnet  created by Docker.</p><h4>Persisting Data</h4><p>  Finally, containers are designed to be disposable, with the ability to run as a single instance on a single host, or  to be scaled as multiple instances distributed over server clusters. By default, data is written to a containers  writable layer and will be disposed of along with the container.</p><p>  Volumes and Bind Mounts are Dockers two options for persisting data. I can, and maybe will, write an entire post to  fully explain them. But to keep it brief I will say Volumes are managed by Docker, isolated from the host, can be  mounted into multiple containers, and stored on remote hosts or in a cloud provider.</p><p>  Bind Mounts are a file or directory on the host machine mounted into a container. They are a good option to share  configuration data, source code, and build artifacts during development. In production, your build artifacts are best  copied directly into the image, configuration in the environment, and source code unnecessary.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/740/1*W49kEOLhKZTuC9DmRKD6Qg.png\" /></figure><p>  Volumes are recommended for storing data used and generated by containers. Bind mounts depend on the host machine’s  directory structure, hampering container portability.</p><p>In this tutorial we will get by with a bind mount.</p><h3>Summary</h3><p>  That’s Docker so far as I understand it. I hope you find it beneficial and are encouraged to begin developing with  Docker. I invite you to join in on the fun below and follow the step-by-step instructions to get down and dirty  with Docker.</p><h3>Tutorial</h3><p>  Let’s setup Drupal 6 within containers in Ubuntu. If you are not using Ubuntu don’t fret, the only step you need to  change is “Install Docker”. In that case refer to  <a    href=\"https://docs.docker.com/install/#supported-platforms\">https://docs.docker.com/install/#supported-platforms</a>  for instructions to install Docker on your OS.</p><p>If you catch any mistakes or see room for improvement please contact me. Otherwise, wacka wacka.</p><h4>Prerequisites</h4><p>  sudo (or root) — Required to install and run Docker. To run docker commands without sudo or root you must add your  user account to the <em>docker</em> group.</p><h4>Table of Contents</h4><ol>  <li>Install Docker</li>  <li>Add user to docker group</li>  <li>Start Docker</li>  <li>Pull MySQL image</li>  <li>Start container</li>  <li>Download Drupal 6</li>  <li>Pull Apache/PHP image</li>  <li>Enable mod_rewrite</li>  <li>Allow Overrides</li>  <li>Start container with a bind mount</li>  <li>Install Drupal</li>  <li>Cleanup</li></ol><p>Biminizha’.</p><h4>Install Docker</h4><p>Open a terminal and ensure your package lists are up to date then install Docker (aka Docker Engine):</p><pre>$ sudo apt update<br>$ sudo apt install docker.io -y</pre><p><em>Output:</em></p><pre>&lt;heaps of output&gt;<br>Processing triggers for systemd (237-3ubuntu10.3) ...</pre><p>Docker Engine is comprised of three major components:</p><ul>  <li><em>dockerd</em> (Server) — a daemon that is a long-running background process</li>  <li><em>docker</em> (Client) — a command line interface</li>  <li>REST API — specifies interfaces that programs can use to communicate with the daemon</li></ul><h4>Start Docker</h4><p>Kick-start the aforementioned long-running background process:</p><pre>$ sudo systemctl start docker</pre><p>Optionally, tell <em>systemd</em> to start docker on system boot:</p><pre>$ sudo systemctl enable docker</pre><p>Docker is now installed and ready for use. Check if docker is running:</p><pre>$ systemctl is-active docker</pre><p><em>Output:</em></p><pre>active</pre><h4>Pull MySQL image</h4><p>  Now that you have docker running you can pull your first image. Start with  <a href=\"https://hub.docker.com/r/mysql/mysql-server/\">MySQL</a> version 5.6 (without <em>:5.6</em>  specified, :<em>latest</em>  is implied):</p><pre>$ sudo docker pull mysql:5.6</pre><p><em>Output:</em></p><pre>5.6: Pulling from library/mysql<br>802b00ed6f79: Pull complete <br>30f19a05b898: Pull complete <br>3e43303be5e9: Pull complete <br>94b281824ae2: Pull complete <br>51eb397095b1: Pull complete <br>3f6fe5e46bae: Pull complete <br>b5a334ca6427: Pull complete <br>115764d35d7a: Pull complete <br>719bba2efabc: Pull complete <br>284e66788ee1: Pull complete <br>0f085ade122c: Pull complete <br>Digest: sha256:4c44f46efaff3ebe7cdc7b35a616c77aa003dc5de4b26c80d0ccae1f9db4a372<br>Status: Downloaded newer image for mysql:5.6</pre><h3>Start MySQL</h3><p>Start the DB container, options are explained below:</p><pre>$ sudo docker run -d \\<br>--name=&quot;drupal-mysql&quot; \\<br>-e MYSQL_ROOT_PASSWORD=drupalroot \\<br>-e MYSQL_DATABASE=drupal6 \\<br>-e MYSQL_USER=drupal \\<br>-e MYSQL_PASSWORD=drupal6pass \\<br>mysql:5.6</pre><ul>  <li>-d — Start the container as a background process.</li>  <li>--name —Will be referenced during Drupal install. A random name will be assigned if one isn’t provided.</li>  <li>    -e — Set’s an environment variable. MySQL will be configured with    <a href=\"https://hub.docker.com/_/mysql/\">values passed in</a> by the environment.  </li></ul><p><em>Output (will differ):</em></p><pre>de99c912e3fbeb4f113889c145b5fab82787259c21d51962c9186e90c27d2857</pre><h4>Download Drupal 6</h4><p>  D6 is available for download from the official Drupal site packaged as a gzipped tarball. You can grab it with wget:</p><pre>$ cd ~<br>$ wget <a href=\"https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz\">https://ftp.drupal.org/files/projects/drupal-6.38.tar.gz</a><br>$ tar -xzf drupal-6.38.tar.gz</pre><p>Verify drupal-6.38 exists in your home directory:</p><pre>$ if test -d ~/drupal-6.38; then echo “It exists”; fi</pre><p><em>Output:</em></p><pre>It exists</pre><h4>Pull Apache/PHP image</h4><p>  Now pull a docker image of Ubuntu 14.04 LTS with Apache 2, PHP 5, and Composer from  <a href=\"https://hub.docker.com/r/nimmis/apache-php5/:\">https://hub.docker.com/r/nimmis/apache-php5/:</a></p><pre>$ sudo docker pull nimmis/apache-php5</pre><p><em>Output:</em></p><pre>Using default tag: latest<br>latest: Pulling from nimmis/apache-php5<br>c2c80a08aa8c: Pull complete <br>6ace04d7a4a2: Pull complete <br>f03114bcfb25: Pull complete <br>99df43987812: Pull complete <br>9c646cd4d155: Pull complete <br>5c017123b62e: Pull complete <br>8f95d9abec41: Pull complete <br>c46de42c66c3: Pull complete <br>9a19620cecad: Pull complete <br>5c62abdf642f: Pull complete <br>Digest: sha256:712d35d5cc30e6a911e260e871f08f77d5684edcc50cba21163535714c547ff5<br>Status: Downloaded newer image for nimmis/apache-php5:latest</pre><h4>DocumentRoot and Incoming Port</h4><p>  The containerized Apache’s default DocumentRoot is /var/www/html, which we will bind mount to the D6 files in  ~/drupal-6.38.</p><p>  Because I already have Apache on the host I have to bind the container’s port 80 to something else. I’m using 10080  but you can choose almost any other free port.</p><pre>$ sudo docker run -d  \\<br>-p 10080:80 \\<br>-v ~/drupal-6.38:/var/www/html \\<br>--name=&quot;drupal-app&quot; \\<br>--link=&quot;drupal-mysql&quot; \\<br>nimmis/apache-php5</pre><p><em>Output:</em></p><pre>0398890ab8e0a082f68373c8e7fd088e925f9bac0eca178399b883091919ee77</pre><p>An explanation of what’s between run and nimmis/apache-php5:</p><ul>  <li>-d — Daemonize, run in background.</li>  <li>-p 10080:80 — Bind host port 10080 to container port 80.</li>  <li>-v ~/drupal-6.38:/var/www/html — Bind host directory to container directory.</li>  <li>— name=&quot;drupal-app&quot; — Name the container instance for convenience.</li>  <li>--link=&quot;drupal-mysql&quot; — Link to the MySQL container so Drupal can communicate with the database.</li></ul><h4>Install Drupal</h4><p>  Open <a href=\"http://localhost:10080\">http://localhost:10080</a> in a browser (<em>xdg-open is a program that will    open a file or URL in the preferred application as set in your OS</em>):</p><pre>$ xdg-open <a href=\"http://localhost:10080\">http://localhost:10080</a></pre><p>Tada! The Drupal 6 installation page should be open in a browser, served from within a set of Docker containers.</p><p>  To complete the installation use the database name (<em>drupal6</em>), username (<em>drupal</em>), and password  (<em>drupal6pass</em>) as set in the <em>Start MySQL</em> step. Under <em>Advanced Options</em>, set the  <em>Database host</em> to the name of your MySQL container, <em>drupal-mysql</em>.</p><h3>Cleanup</h3><p>When you have finished with Drupal 6 shut down the containers and delete them from the host.</p><p>Stop the containers:</p><pre>$ sudo docker container stop drupal-app drupal-mysql</pre><p><em>Output:</em></p><pre>drupal-app<br>drupal-mysql</pre><p>Remove the containers:</p><pre>$ sudo docker container rm drupal-app drupal-mysql</pre><p><em>Output:</em></p><pre>drupal-app<br>drupal-mysql</pre><p>Verify the containers have been deleted:</p><pre>$ sudo docker container ls</pre><p>That’s it, move along. Baamaapii.</p><h3>Bonus: <em>docker</em> group</h3><p>To display a list of groups you belong to is simple:</p><pre>$ group</pre><p><em>Output:</em></p><pre>roosta adm cdrom sudo dip plugdev lpadmin sambashare</pre><p>Add your user account to the <em>docker</em> group:</p><pre>$ sudo usermod -aG docker $USER</pre><p>You must log out then log back in before it takes effect.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6df4dec8b309\" width=\"1\"  height=\"1\" />",
            "url": "https://blog.jonesrussell42.xyz/devops/2018/10/14/docker-for-legacy-drupal-development.html",
            "image": "https://cdn-images-1.medium.com/max/1024/1*s-YgL1NW7evYyCBWI-7w8Q.png",
            
            
            "tags": ["drupal","docker"],
            
            "date_published": "2018-10-14T00:00:00+00:00",
            "date_modified": "2018-10-14T00:00:00+00:00",
            
                "author": 
                ""
                
            
        },
    
        {
            "id": "github-static-site-generators-2018-09-29-scaffold-and-deploy-a-jekyll-github-pages-blog-in-5-minutes",
            "title": "Scaffold and Deploy a Jekyll GitHub Pages Blog in 5 Minutes",
            "summary": null,
            "content_text": "  Ahnee! Static websites have made a comeback. Innovations in content generation, the adoption of Markdown in workflows,  deployment technology, and free hosting have made static websites an attractive option for those who don’t need the  capabilities of a framework or content management system.  Jekyll is a static site generator that made a big splash in the world of static  website generation. And GitHub has become the defacto standard in social coding, with  GitHub Pages offered as an attractive option for free static website hosting.Jekyll is a blog-aware static site generator in RubyMy experience in static  18 years ago, in my first job as a web developer, we generated and maintained static websites. The shop I worked for  built an in-house Perl templating “engine” which recursively crawled a directory looking for files with a custom file  extension to parse.  These files contained content in the form of HTML and XML-esque tags which were essentially variables that set the  active section in the navigation, helped generate breadcrumbs, figure out which shared content blocks to display in  the sidebars, etc… The meat of each file was the content for the page being generated. Using regex, the contents of a  master template was then populated with the contents of the parsed files then output into an html file.  The websites were generally 100+ pages and the engine wasn’t great. There was no easy way to generate a single page,  or a subset of pages. And it was slow. We would inevitably edit the HTML files directly when doing maintenance work.  Site-wide changes ended up being a scary Perl regexp which ran independently of the engine, and our master template  would quickly become obsolete.Today we have much better tooling. Written in Ruby, Jekyll is arguably the most popular static site generator.Why develop a static website?Why indeed. I can think of a few pros to creating and maintaining a static website.      No server side programming requiredCreating a website usually begins with a framework. The    most popular software for creating websites today is Wordpress. Written in PHP, WP began as a blogging platform but    has since progressed to a full fledged Content Management System. A WordPress website requires a server which    supports PHP, which you can setup yourself or pay a hosting provider like    https://wordpress.com/. It’s definitely possible to create a WordPress website    without knowing PHP, but to customize your site, you will eventually have to get your hands dirty with a bit    of coding.        Your website will be fastA static web page is written in HTML and is served by a web server    such as Apache or Nginx. Because the HTML document does not require any additional processing, it is served directly    to the browser with minimal effort on the web servers part. Web servers such as Nginx are optimized for serving    static assets, resulting in web pages which load near instantaneously.        Search engines favor fast web pagesGoogle provides us with guidelines for Search Engine    Optimization. In 2012, Google revealed that speed is a factor in rankings.  TutorialEnough talk, let’s get down to generating our new site.Pre-requisites      Terminal (a command-line) —    How to open Terminal on      Ubuntu Bionic Beaver 18.04 Linux    RubyGems — RVM package for Ubuntu      Git —    How To Install Git on      Ubuntu 18.04    A GitHub account — Join GitHub  Installing ‘gem’ and ‘git’ is out of the scope of this tutorial but the links provided above are great for Ubuntu  18.04. Drop me a line or comment below if you need help.Create and Preview Your SiteTo kick off, first you need to open a terminal and install the Jekyll ruby gem:$ gem install bundler jekyllUse jekyll to generate your awesome new site:$ jekyll new my-awesome-siteIf all went well you can use jekyll to preview your new site:$ cd my-awesome-site$ bundle exec jekyll servePoint your browser to http://localhost:4000.When you are finished previewing press Ctrl-C to shut down the preview server.Deploy to GitHub Pages  GitHub Pages is an excellent FREE web hosting service for your GitHub  repositories.  Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your  changes are live.Create a New RepositoryA repository (or repo for short) is a place to manage a project and track changes to project files over time.Visit https://github.com/newUnder “Repository name” type “my-awesome-site”Optionally fill in a “Description”:  Leave “Public” selected (“Private” repos are only available with paid GitHub plans), and leave all other options  as is.To continue, click “Create repository”. When your repo is created you will see this screen:You now have an empty repo and may continue with configuration.Configure Repository for GitHub PagesTo link your repository to GitHub Pages you must specify which branch will be published.  A git branch is essentially a series of  snapshots of your code over time. Branching allows you, or multiple users, to modify code in an isolated work area  that doesn’t affect other branches or the project as a whole.For the purpose of this tutorial we will assign the “master” branch to be published.  From your “my-awesome-site” repository page click the “Settings” tab which brings you to  https://github.com/username/my-awesome-site/settings.Scroll down to “GitHub Pages” where you will see “Source” with a drop-down set to “None”.Click the drop-down and select “master branch”:With “master branch” selected, click “Save”.  Once saved scroll back down to see the message “Your site is ready to be published at  https://username.github.io/my-awesome-site/.”Configure your Gemfile  Gemfiles are used by Ruby to set the dependencies required to properly build a Ruby Gem. A Gemfile was automatically  generated by Jekyll in the previous steps.You must update your Gemfile to instruct GitHub to build your gem for deployment to GitHub Pages.Use whichever editor you are comfortable with but here I’m using “vim”:$ vim GemfileOur changes are straight-forward, simply comment out (append the line with #):  gem “jekyll”, “~&gt; 3.8.4” (line 11 in the above screenshot; 3.8.4 is the version at the time of writing and may have  changed by now)and un-comment:# gem “github-pages”, group: :jekyll_plugins (line 18)  Your Gemfile should now look like the screenshot below. A ‘#’ has been appended to line 11, and the ‘#’ has been  removed from the beginning of line 18.Now Save and close the Gemfile (instructions for vim)::wqUpdate _config.yml  _config.yml contains variables specific to your website. Before you deploy you may want to set the title and  description, and possibly your Twitter and GitHub usernames.  You must set the baseurl to ensure URLs are generated correctly, otherwise your assets and page links will not work.$ vim _config.ymlMake whatever edits you like, but be sure to edit the “baseurl” (line 22) so it reads:baseurl: “/my-awesome-site” # the subpath of your site, e.g. /blogSave and close.:wqCommit Your Site Files  You have your site files, configured for GitHub Pages, and you have an empty GitHub repository named  “my-awesome-site”.The next step is to “check-in” your files to the repo (replace username with your GitHub username):  $ git init$ git add .$ git commit -m “first commit”$ git remote add origin  https://github.com/username/my-awesome-site.git$  git push -u origin master  Verify your files have been published to GitHub by visiting  https://github.com/username/my-awesome-site:Tada! Visit your site  When you committed your files to the repository, GitHub automagically built a set of HTML files and deployed to  GitHub pages.  Verify your blog is deployed by visiting  https://username.github.io/my-awesome-site/.Conclusion  You are now initiated into the world of Jekyll and GitHub Pages. To create a new blog post, add a new file to the  “_posts” directory and check it into your repo. Be sure to examine the default post and stick to it’s naming  convention and the template it uses within. Once checked in visit your site and your new post should appear in the  homepage list.I hope this post was helpful, drop me a line or comment with any questions, corrections, or just to say Ahnee!Gabekana!",
            "content_html": "<p>  Ahnee! Static websites have made a comeback. Innovations in content generation, the adoption of Markdown in workflows,  deployment technology, and free hosting have made static websites an attractive option for those who don’t need the  capabilities of a framework or content management system.</p><p>  <a href=\"https://jekyllrb.com/\">Jekyll</a> is a static site generator that made a big splash in the world of static  website generation. And GitHub has become the defacto standard in social coding, with  <a href=\"https://pages.github.com/\">GitHub Pages</a> offered as an attractive option for free static website hosting.</p><blockquote>Jekyll is a blog-aware static site generator in Ruby</blockquote><h3>My experience in static</h3><p>  18 years ago, in my first job as a web developer, we generated and maintained static websites. The shop I worked for  built an in-house Perl templating “engine” which recursively crawled a directory looking for files with a custom file  extension to parse.</p><p>  These files contained content in the form of HTML and XML-esque tags which were essentially variables that set the  active section in the navigation, helped generate breadcrumbs, figure out which shared content blocks to display in  the sidebars, etc… The meat of each file was the content for the page being generated. Using regex, the contents of a  master template was then populated with the contents of the parsed files then output into an html file.</p><p>  The websites were generally 100+ pages and the engine wasn’t great. There was no easy way to generate a single page,  or a subset of pages. And it was slow. We would inevitably edit the HTML files directly when doing maintenance work.  Site-wide changes ended up being a scary Perl regexp which ran independently of the engine, and our master template  would quickly become obsolete.</p><p>Today we have much better tooling. Written in Ruby, Jekyll is arguably the most popular static site generator.</p><h3>Why develop a static website?</h3><p>Why indeed. I can think of a few pros to creating and maintaining a static website.</p><ul>  <li>    <strong>No server side programming required</strong><br />Creating a website usually begins with a framework. The    most popular software for creating websites today is Wordpress. Written in PHP, WP began as a blogging platform but    has since progressed to a full fledged Content Management System. A WordPress website requires a server which    supports PHP, which you can setup yourself or pay a hosting provider like    <a href=\"https://wordpress.com/\">https://wordpress.com/</a>. It’s definitely possible to create a WordPress website    without knowing PHP, but to customize your site, you will eventually have to get your hands dirty with a bit    of coding.  </li>  <li>    <strong>Your website will be fast</strong><br />A static web page is written in HTML and is served by a web server    such as Apache or Nginx. Because the HTML document does not require any additional processing, it is served directly    to the browser with minimal effort on the web servers part. Web servers such as Nginx are optimized for serving    static assets, resulting in web pages which load near instantaneously.  </li>  <li>    <strong>Search engines favor fast web pages<br /></strong>Google provides us with guidelines for Search Engine    Optimization. In 2012, Google revealed that speed is a factor in rankings.  </li></ul><h3>Tutorial</h3><p>Enough talk, let’s get down to generating our new site.</p><h4>Pre-requisites</h4><ul>  <li>    Terminal (a command-line) —    <a href=\"https://linuxconfig.org/how-to-open-a-terminal-on-ubuntu-bionic-beaver-18-04-linux\">How to open Terminal on      Ubuntu Bionic Beaver 18.04 Linux</a>  </li>  <li>RubyGems — <a href=\"https://github.com/rvm/ubuntu_rvm\">RVM package for Ubuntu</a></li>  <li>    Git —    <a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-18-04\">How To Install Git on      Ubuntu 18.04</a>  </li>  <li>A GitHub account — <a href=\"https://github.com/join\">Join GitHub</a></li></ul><p>  Installing ‘gem’ and ‘git’ is out of the scope of this tutorial but the links provided above are great for Ubuntu  18.04. Drop me a line or comment below if you need help.</p><h4>Create and Preview Your Site</h4><p>To kick off, first you need to open a terminal and install the Jekyll ruby gem:</p><blockquote>$ gem install bundler jekyll</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*o-WMlkQ2Cra6pT0O8HSeVQ.png\" /></figure><p>Use jekyll to generate your awesome new site:</p><blockquote>$ jekyll new my-awesome-site</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*fphO0ihPGqX8UZ8B_P-pdg.png\" /></figure><p>If all went well you can use jekyll to preview your new site:</p><blockquote>$ cd my-awesome-site<br />$ bundle exec jekyll serve</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*TGha9u_EC39odTSBF4nETQ.png\" /></figure><blockquote>Point your browser to <a href=\"http://localhost:4000\">http://localhost:4000</a>.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iaupqu3_PhnF1iRCDlYZng.png\" /></figure><blockquote>When you are finished previewing press Ctrl-C to shut down the preview server.</blockquote><h3>Deploy to GitHub Pages</h3><p>  <a href=\"https://pages.github.com/\">GitHub Pages</a> is an excellent FREE web hosting service for your GitHub  repositories.</p><blockquote>  Websites for you and your projects.<br />Hosted directly from your GitHub repository. Just edit, push, and your  changes are live.</blockquote><h4>Create a New Repository</h4><p>A repository (or repo for short) is a place to manage a project and track changes to project files over time.</p><blockquote>Visit <a href=\"https://github.com/new\">https://github.com/new</a></blockquote><blockquote>Under “Repository name” type “my-awesome-site”</blockquote><blockquote>Optionally fill in a “Description”:</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*n_waIDZ75IoaJxPdNvD0EA.png\" /></figure><p>  Leave “Public” selected (“Private” repos are only available with paid GitHub plans), and leave all other options  as is.</p><blockquote>To continue, click “Create repository”. When your repo is created you will see this screen:</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Fibe17D9cKelwO2amQP0ag.png\" /></figure><p>You now have an empty repo and may continue with configuration.</p><h4>Configure Repository for GitHub Pages</h4><p>To link your repository to GitHub Pages you must specify which branch will be published.</p><p>  A <a href=\"https://git-scm.com/book/en/v1/Git-Branching-What-a-Branch-Is\">git branch</a> is essentially a series of  snapshots of your code over time. Branching allows you, or multiple users, to modify code in an isolated work area  that doesn’t affect other branches or the project as a whole.</p><p>For the purpose of this tutorial we will assign the “master” branch to be published.</p><blockquote>  From your “my-awesome-site” repository page click the “Settings” tab which brings you to  <a    href=\"https://github.com/jonesrussell/my-awesome-site/settings\">https://github.com/<em>username</em>/my-awesome-site/settings</a>.</blockquote><blockquote>Scroll down to “GitHub Pages” where you will see “Source” with a drop-down set to “None”.</blockquote><blockquote>Click the drop-down and select “master branch”:</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uGIFFtwSc7L0-QnmKAXORA.png\" /></figure><blockquote>With “master branch” selected, click “Save”.</blockquote><p>  Once saved scroll back down to see the message “Your site is ready to be published at  <a href=\"https://jonesrussell.github.io/my-awesome-site/\">https://<em>username</em>.github.io/my-awesome-site/</a>.”</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*MQwnvC6Inb93zlev6ZuYRQ.png\" /></figure><p><strong>Configure your Gemfile</strong></p><p>  Gemfiles are used by Ruby to set the dependencies required to properly build a Ruby Gem. A Gemfile was automatically  generated by Jekyll in the previous steps.</p><p>You must update your Gemfile to instruct GitHub to build your gem for deployment to GitHub Pages.</p><p>Use whichever editor you are comfortable with but here I’m using “vim”:</p><blockquote>$ vim Gemfile</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*Bh6_5s7-bqE7CAfAK-HyNw.png\" /></figure><p>Our changes are straight-forward, simply comment out (append the line with #):</p><blockquote>  gem “jekyll”, “~&gt; 3.8.4” (line 11 in the above screenshot; 3.8.4 is the version at the time of writing and may have  changed by now)</blockquote><p>and un-comment:</p><blockquote># gem “github-pages”, group: :jekyll_plugins (line 18)</blockquote><p>  Your Gemfile should now look like the screenshot below. A ‘#’ has been appended to line 11, and the ‘#’ has been  removed from the beginning of line 18.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*9mMkQCJzxLCmXL_I5yfm1g.png\" /></figure><p>Now Save and close the Gemfile (instructions for vim):</p><blockquote>:wq</blockquote><p><strong>Update _config.yml</strong></p><p>  _config.yml contains variables specific to your website. Before you deploy you may want to set the title and  description, and possibly your Twitter and GitHub usernames.</p><p>  You must set the baseurl to ensure URLs are generated correctly, otherwise your assets and page links will not work.</p><blockquote>$ vim _config.yml</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*9UEZoWCCdQYb4_ah0aXFKw.png\" /></figure><p>Make whatever edits you like, but be sure to edit the “baseurl” (line 22) so it reads:</p><blockquote>baseurl: “/my-awesome-site” # the subpath of your site, e.g. /blog</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*wku2TAwAraDwe4GCoxINHg.png\" /></figure><p>Save and close.</p><blockquote>:wq</blockquote><p><strong>Commit Your Site Files</strong></p><p>  You have your site files, configured for GitHub Pages, and you have an empty GitHub repository named  “my-awesome-site”.</p><p>The next step is to “check-in” your files to the repo (replace <em>username</em> with your GitHub username):</p><blockquote>  $ git init<br />$ git add .<br />$ git commit -m “first commit”<br />$ git remote add origin  <a    href=\"https://github.com/jonesrussell/my-awesome-site.git\">https://github.com/username/my-awesome-site.git</a><br />$  git push -u origin master</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/741/1*XFr7LjpYyynfAapn9UnKlw.png\" /></figure><blockquote>  Verify your files have been published to GitHub by visiting  <a href=\"https://github.com/jonesrussell/my-awesome-site\">https://github.com/<em>username</em>/my-awesome-site</a>:</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*550RFFagQa4dtiXMZkZfdw.png\" /></figure><p><strong>Tada! Visit your site</strong></p><p>  When you committed your files to the repository, GitHub automagically built a set of HTML files and deployed to  GitHub pages.</p><blockquote>  Verify your blog is deployed by visiting  <a href=\"https://jonesrussell.github.io/my-awesome-site/\">https://username.github.io/my-awesome-site/</a>.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lP_yQX0QSLepJ29IenSFjQ.png\" /></figure><h3>Conclusion</h3><p>  You are now initiated into the world of Jekyll and GitHub Pages. To create a new blog post, add a new file to the  “_posts” directory and check it into your repo. Be sure to examine the default post and stick to it’s naming  convention and the template it uses within. Once checked in visit your site and your new post should appear in the  homepage list.</p><p>I hope this post was helpful, drop me a line or comment with any questions, corrections, or just to say Ahnee!</p><p>Gabekana!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=356a20793149\" width=\"1\"  height=\"1\" />",
            "url": "https://blog.jonesrussell42.xyz/github/static-site-generators/2018/09/29/scaffold-and-deploy-a-jekyll-github-pages-blog-in-5-minutes.html",
            "image": "https://cdn-images-1.medium.com/max/752/1*o-WMlkQ2Cra6pT0O8HSeVQ.png",
            
            
            "tags": ["ruby","jekyll","github-pages","blog"],
            
            "date_published": "2018-09-29T00:00:00+00:00",
            "date_modified": "2018-09-29T00:00:00+00:00",
            
                "author": 
                ""
                
            
        }
    
    ]
}
